package main

import (
	"crypto/sha256"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"text/template"
)

type FrameMetadata struct {
	FrameID int
	Hash    string
}

const outputTemplate = `// Code generated by cmd/generate-video-metadata. DO NOT EDIT.
//
// To regenerate this file:
//   go run cmd/generate-video-metadata/main.go
//
// This will automatically extract frames if they don't exist.
// Frame PNGs are NOT committed to repository (62MB).
// They are generated on-demand from data/test-data/videos/e2e-test.mp4

package video

// FrameMetadata contains hash information for a video frame
type FrameMetadata struct {
	FrameID int
	Hash    string
}

// E2ETestVideoMetadata contains pre-calculated hashes for all frames in e2e-test.mp4
// Video specs: 480x360, 10fps, 20 seconds, 200 frames
// Generated from: data/test-data/video-frames/e2e-test/frame_*.png
var E2ETestVideoMetadata = []FrameMetadata{
{{- range .Frames}}
	{FrameID: {{.FrameID}}, Hash: "{{.Hash}}"},
{{- end}}
}

// GetFrameMetadata returns metadata for a specific frame ID
func GetFrameMetadata(frameID int) *FrameMetadata {
	if frameID < 0 || frameID >= len(E2ETestVideoMetadata) {
		return nil
	}
	return &E2ETestVideoMetadata[frameID]
}

// ValidateFrameHash checks if a frame's hash matches expected metadata
func ValidateFrameHash(frameID int, hash string) bool {
	metadata := GetFrameMetadata(frameID)
	if metadata == nil {
		return false
	}
	return metadata.Hash == hash
}
`

func ensureFramesExist(framesDir string) ([]string, error) {
	files, err := filepath.Glob(filepath.Join(framesDir, "frame_*.png"))
	if err != nil {
		return nil, fmt.Errorf("error reading frames: %w", err)
	}

	if len(files) > 0 {
		return files, nil
	}

	fmt.Println("No frame files found, extracting frames from video...")
	fmt.Println("Running: ./scripts/tools/extract-frames.sh")

	cmd := exec.Command("./scripts/tools/extract-frames.sh")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if cmdErr := cmd.Run(); cmdErr != nil {
		return nil, fmt.Errorf("failed to extract frames: %w", cmdErr)
	}

	files, globErr := filepath.Glob(filepath.Join(framesDir, "frame_*.png"))
	if globErr != nil || len(files) == 0 {
		return nil, fmt.Errorf("frame extraction completed but no files found")
	}

	fmt.Println("Frame extraction completed successfully!")
	fmt.Println()

	return files, nil
}

func generateMetadata(files []string) ([]FrameMetadata, error) {
	var frames []FrameMetadata

	for i, file := range files {
		fileData, readErr := os.ReadFile(file)
		if readErr != nil {
			return nil, fmt.Errorf("error reading %s: %w", file, readErr)
		}

		hash := sha256.Sum256(fileData)
		hashStr := fmt.Sprintf("%x", hash)

		frames = append(frames, FrameMetadata{
			FrameID: i,
			Hash:    hashStr,
		})

		if i < 3 || i >= len(files)-3 {
			fmt.Printf("Frame %04d: %s... (%s)\n", i, hashStr[:16], filepath.Base(file))
		} else if i == 3 {
			fmt.Printf("...\n")
		}
	}

	return frames, nil
}

func writeMetadataFile(outputFile string, frames []FrameMetadata) error {
	tmpl, err := template.New("metadata").Parse(outputTemplate)
	if err != nil {
		return fmt.Errorf("error parsing template: %w", err)
	}

	outputDir := filepath.Dir(outputFile)
	if mkdirErr := os.MkdirAll(outputDir, 0755); mkdirErr != nil {
		return fmt.Errorf("error creating output directory: %w", mkdirErr)
	}

	f, createErr := os.Create(outputFile)
	if createErr != nil {
		return fmt.Errorf("error creating output file: %w", createErr)
	}

	data := struct {
		Frames []FrameMetadata
	}{
		Frames: frames,
	}

	if execErr := tmpl.Execute(f, data); execErr != nil {
		f.Close()
		return fmt.Errorf("error executing template: %w", execErr)
	}

	if closeErr := f.Close(); closeErr != nil {
		return fmt.Errorf("error closing file: %w", closeErr)
	}

	return nil
}

func main() {
	framesDir := "data/test-data/video-frames/e2e-test"
	outputFile := "webserver/pkg/infrastructure/video/test_video_metadata.go"

	fmt.Println("Generating video frame metadata...")
	fmt.Printf("Input: %s\n", framesDir)
	fmt.Printf("Output: %s\n", outputFile)
	fmt.Println()

	files, err := ensureFramesExist(framesDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		fmt.Fprintf(os.Stderr, "Please run ./scripts/tools/extract-frames.sh manually\n")
		os.Exit(1)
	}

	sort.Strings(files)

	frames, err := generateMetadata(files)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\nTotal frames processed: %d\n", len(frames))

	if err := writeMetadataFile(outputFile, frames); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\nMetadata file generated successfully!\n")
	fmt.Printf("Location: %s\n", outputFile)
	fmt.Printf("\nYou can now use this metadata in tests:\n")
	fmt.Printf("  - video.GetFrameMetadata(frameID)\n")
	fmt.Printf("  - video.ValidateFrameHash(frameID, hash)\n")
}
