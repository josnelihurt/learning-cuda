syntax = "proto3";

package cuda_learning;

option go_package = "github.com/jrb/cuda-learning/proto";

// Request: Go passes raw image buffer
message ProcessImageRequest {
  bytes image_data = 1;      // Raw pixel data (RGBA or agreed format)
  int32 width = 2;
  int32 height = 3;
  int32 channels = 5;        // 3=RGB, 4=RGBA
  repeated FilterType filters = 10;  // Array of filters to apply sequentially
  AcceleratorType accelerator = 11;  // GPU or CPU processing
  GrayscaleType grayscale_type = 12; // Grayscale algorithm selection
}

// Enum for filter types
enum FilterType {
  FILTER_TYPE_UNSPECIFIED = 0;
  FILTER_TYPE_NONE = 1;
  FILTER_TYPE_GRAYSCALE = 2;
  // Future: FILTER_TYPE_BLUR = 5, FILTER_TYPE_EDGE_DETECT = 10, etc.
}

// Enum for accelerator types
enum AcceleratorType {
  ACCELERATOR_TYPE_UNSPECIFIED = 0;
  ACCELERATOR_TYPE_GPU = 1;
  ACCELERATOR_TYPE_CPU = 2;
}

// Enum for grayscale conversion algorithms
enum GrayscaleType {
  GRAYSCALE_TYPE_UNSPECIFIED = 0;
  GRAYSCALE_TYPE_BT601 = 1;      // ITU-R BT.601 (SDTV): Y = 0.299R + 0.587G + 0.114B
  GRAYSCALE_TYPE_BT709 = 2;      // ITU-R BT.709 (HDTV): Y = 0.2126R + 0.7152G + 0.0722B
  GRAYSCALE_TYPE_AVERAGE = 3;    // Simple average: Y = (R + G + B) / 3
  GRAYSCALE_TYPE_LIGHTNESS = 4;  // Lightness: Y = (max(R,G,B) + min(R,G,B)) / 2
  GRAYSCALE_TYPE_LUMINOSITY = 5; // Luminosity: Y = 0.21R + 0.72G + 0.07B (similar to BT709)
}

// Response: C++ returns processed image buffer
message ProcessImageResponse {
  int32 code = 1;            // 0=success, non-zero=error (gRPC style)
  string message = 2;        // Status message or error description
  bytes image_data = 5;      // Processed pixel data
  int32 width = 10;
  int32 height = 11;
  int32 channels = 12;
}

// Lifecycle management
message InitRequest {
  int32 cuda_device_id = 1;  // Default 0
  // Future: memory_pool_size = 5, enable_profiling = 10, etc.
}

message InitResponse {
  int32 code = 1;            // 0=success, non-zero=error
  string message = 2;        // Status or error message
}

