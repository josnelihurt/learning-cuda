---
- name: Prepare Proxmox host for GitHub runner template
  hosts: proxmox
  gather_facts: false
  become: true
  vars:
    runner_template_storage: "{{ runner_template.split(':')[0] }}"
    runner_template_path: "{{ runner_template.split(':')[1] }}"
    runner_template_filename: "{{ runner_template_path.split('/')[-1] }}"
    runner_template_cache_dir: "/var/lib/vz/template/cache"
    runner_template_cache_path: "{{ runner_template_cache_dir }}/{{ runner_template_filename }}"
  tasks:
    - name: Prepare template cache on Proxmox
      when: proxmox_host_tasks_enabled | bool
      block:
        - name: Ensure template cache directory exists
          ansible.builtin.file:
            path: "{{ runner_template_cache_dir }}"
            state: directory
            mode: "0755"

        - name: Download runner template if missing
          ansible.builtin.command:
            cmd: "pveam download {{ runner_template_storage }} {{ runner_template_filename }}"
            creates: "{{ runner_template_cache_path }}"
          register: runner_template_download
          changed_when: runner_template_download.rc == 0

        - name: Display token guidance
          ansible.builtin.debug:
            msg:
              - "Ensure the Proxmox API token configured in .secrets/proxmox-api.key has Administrator privileges."
              - "Current API endpoint: {{ proxmox_host }}"

    - name: Proxmox host tasks skipped
      ansible.builtin.debug:
        msg: "Skipping Proxmox host preparation (set PROXMOX_SSH_KEY_PATH to enable)."
      when: not (proxmox_host_tasks_enabled | bool)

- name: Configure GitHub Actions runner container
  hosts: runner
  gather_facts: false
  vars:
    runner_labels_list: >-
      {% if runner_labels is iterable and runner_labels is not string %}
      {{ runner_labels | list }}
      {% elif runner_labels is string %}
      {{ runner_labels | from_yaml }}
      {% else %}
      []
      {% endif %}
    runner_labels_csv: "{{ runner_labels_csv | default(runner_labels_list | join(',')) }}"
    runner_service_name: "actions.runner.{{ runner_repo | replace('/', '-') }}.{{ runner_name }}"
  tasks:
    - name: Wait for SSH on runner container
      become: false
      ansible.builtin.wait_for:
        host: "{{ runner_host }}"
        port: 22
        state: started
        timeout: 300
      delegate_to: localhost

    - name: Bootstrap Python for Ansible modules
      ansible.builtin.raw: |
        if command -v python3 >/dev/null 2>&1; then
          exit 0
        fi
        export DEBIAN_FRONTEND=noninteractive
        apt-get update -y
        apt-get install -y python3 python3-apt
      changed_when: false
      args:
        warn: false

    - name: Install runner dependencies
      ansible.builtin.apt:
        name:
          - curl
          - jq
          - tar
          - git
          - ca-certificates
          - apt-transport-https
          - software-properties-common
          - docker.io
          - python3
          - python3-apt
          - python3-venv
          - python3-pip
          - python-is-python3
        state: present
        update_cache: true

    - name: Ensure Docker service is enabled
      ansible.builtin.service:
        name: docker
        state: started
        enabled: true

    - name: Create runner working directory
      ansible.builtin.file:
        path: "{{ runner_workdir }}"
        state: directory
        owner: root
        group: root
        mode: "0755"

    - name: Check existing runner configuration
      ansible.builtin.stat:
        path: "{{ runner_workdir }}/.runner"
      register: runner_state

    - name: Obtain GitHub Actions registration token
      become: false
      ansible.builtin.command:
        cmd: "gh api --method POST repos/{{ runner_repo }}/actions/runners/registration-token --jq .token"
      delegate_to: localhost
      register: runner_registration_token
      changed_when: false
      when: not runner_state.stat.exists

    - name: Lookup existing runner ID
      become: false
      ansible.builtin.command:
        cmd: >-
          gh api repos/{{ runner_repo }}/actions/runners --paginate
          --jq '.runners[] | select(.name == "{{ runner_name }}") | .id'
      delegate_to: localhost
      register: runner_existing_id
      changed_when: false

    - name: Remove existing runner with same name
      become: false
      ansible.builtin.command:
        cmd: "gh api repos/{{ runner_repo }}/actions/runners/{{ runner_existing_id.stdout }} --method DELETE"
      delegate_to: localhost
      register: runner_removed
      changed_when: runner_removed.rc == 0
      when: runner_existing_id.stdout | length > 0

    - name: Download runner archive
      ansible.builtin.get_url:
        url: "{{ runner_image_url }}"
        dest: "{{ runner_workdir }}/runner.tar.gz"
        mode: "0644"
      when: not runner_state.stat.exists

    - name: Extract runner archive
      ansible.builtin.unarchive:
        src: "{{ runner_workdir }}/runner.tar.gz"
        dest: "{{ runner_workdir }}"
        remote_src: true
      when: not runner_state.stat.exists

    - name: Configure runner service
      ansible.builtin.shell: >-
        ./config.sh --unattended
        --url https://github.com/{{ runner_repo }}
        --token {{ runner_registration_token.stdout }}
        {% if runner_labels_csv %} --labels {{ runner_labels_csv }}{% endif %}
        --name {{ runner_name }}
      args:
        chdir: "{{ runner_workdir }}"
      environment:
        RUNNER_ALLOW_RUNASROOT: "1"
      when: not runner_state.stat.exists

    - name: Install runner service
      ansible.builtin.command:
        cmd: "./svc.sh install"
        chdir: "{{ runner_workdir }}"
      environment:
        RUNNER_ALLOW_RUNASROOT: "1"
      when: not runner_state.stat.exists

    - name: Ensure runner service is running
      ansible.builtin.command:
        cmd: "./svc.sh start"
        chdir: "{{ runner_workdir }}"
      register: runner_start
      changed_when: runner_start.rc == 0

    - name: Validate Python availability
      ansible.builtin.command:
        cmd: python --version
      changed_when: false

    - name: Summarize runner service status
      ansible.builtin.debug:
        msg:
          - "Runner service started: {{ runner_service_name }}"
          - "Runner labels: {{ runner_labels_csv if runner_labels_csv else 'none' }}"

- name: Configure Bazel remote cache host
  hosts: bazel_cache
  gather_facts: false
  become: true
  vars:
    bazel_remote_download_url: "https://github.com/buchgr/bazel-remote/releases/download/v{{ bazel_remote_version }}/bazel-remote-{{ bazel_remote_version }}-{{ bazel_remote_arch }}"
    bazel_remote_flags: [
      "--dir={{ bazel_remote_cache_dir }}",
      "--max_size={{ bazel_remote_max_size_gib }}",
      "--http_address={{ bazel_remote_http_address }}:{{ bazel_remote_http_port }}",
      "--grpc_address={{ bazel_remote_grpc_address }}",
    ]
  tasks:
    - name: Validate Bazel cache connection variables
      ansible.builtin.assert:
        that:
          - bazel_cache_host is defined
        fail_msg: "bazel_cache_host must be defined to configure the Bazel cache."

    - name: Wait for SSH on Bazel cache host
      become: false
      ansible.builtin.wait_for:
        host: "{{ bazel_cache_host }}"
        port: 22
        state: started
        timeout: 300
      delegate_to: localhost

    - name: Install required packages
      ansible.builtin.apt:
        name:
          - ca-certificates
          - curl
          - xz-utils
        state: present
        update_cache: true

    - name: Ensure Bazel remote service group exists
      ansible.builtin.group:
        name: "{{ bazel_remote_service_group }}"
        system: true

    - name: Ensure Bazel remote service user exists
      ansible.builtin.user:
        name: "{{ bazel_remote_service_user }}"
        system: true
        create_home: false
        group: "{{ bazel_remote_service_group }}"

    - name: Ensure Bazel cache directories exist
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: "{{ bazel_remote_service_user }}"
        group: "{{ bazel_remote_service_group }}"
        mode: "0750"
      loop:
        - "{{ bazel_remote_cache_dir }}"
        - "{{ bazel_remote_tmp_dir }}"

    - name: Remove legacy tmp directory inside cache root
      ansible.builtin.file:
        path: "{{ bazel_remote_cache_dir }}/tmp"
        state: absent

    - name: Download bazel-remote binary
      ansible.builtin.get_url:
        url: "{{ bazel_remote_download_url }}"
        dest: "{{ bazel_remote_bin_path }}"
        owner: root
        group: root
        mode: "0755"
        checksum: "{{ bazel_remote_checksum | default(omit, true) }}"

    - name: Configure systemd service for bazel-remote
      ansible.builtin.copy:
        dest: /etc/systemd/system/bazel-remote.service
        owner: root
        group: root
        mode: "0644"
        content: |
          [Unit]
          Description=Bazel Remote Cache
          After=network-online.target
          Wants=network-online.target

          [Service]
          Type=simple
          User={{ bazel_remote_service_user }}
          Group={{ bazel_remote_service_group }}
          ExecStart={{ bazel_remote_bin_path }} {{ bazel_remote_flags | join(' ') }}
          WorkingDirectory={{ bazel_remote_cache_dir }}
          Environment=TMPDIR={{ bazel_remote_tmp_dir }}
          Restart=on-failure
          RestartSec=5
          LimitNOFILE=65536

          [Install]
          WantedBy=multi-user.target

    - name: Reload systemd daemon
      ansible.builtin.systemd:
        daemon_reload: true

    - name: Ensure bazel-remote service is enabled and running
      ansible.builtin.systemd:
        name: bazel-remote.service
        state: started
        enabled: true

    - name: Wait for bazel-remote HTTP port
      ansible.builtin.wait_for:
        host: "{{ bazel_cache_host }}"
        port: "{{ bazel_remote_http_port }}"
        delay: 2
        timeout: 60
      delegate_to: localhost
      become: false

    - name: Validate bazel-remote status endpoint
      become: false
      ansible.builtin.uri:
        url: "http://{{ bazel_cache_host }}:{{ bazel_remote_http_port }}/status"
        method: GET
        status_code: 200
      register: bazel_remote_status
      retries: 5
      delay: 5
      until: bazel_remote_status.status == 200
